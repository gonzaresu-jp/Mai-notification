<!doctype html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ãƒ†ã‚¹ãƒˆå®Œäº†ï¼</title>
    <link rel="icon" href="./icon.ico">
    <link rel="stylesheet" href="./style.css" />

    <script src="https://unpkg.com/@lottiefiles/lottie-player@2.0.2/dist/lottie-player.js"></script>
<style type="text/css">
    /* éè¡¨ç¤ºã«ã™ã‚‹ãŸã‚ã®ã‚¯ãƒ©ã‚¹ */
.hidden {
  display: none!important;
}

/* è¡¨ç¤ºã‚’åˆ¶å¾¡ã™ã‚‹ã‚³ãƒ³ãƒ†ãƒŠ */
#animation-container,
#animation-container-other {display: flex; justify-content: flex-end; align-items: flex-start; width: 100%; height: 90vh;}
</style>
</head>
<body id="app-body">
    <header>
        <div class="header-left">
            <h2>ãƒ†ã‚¹ãƒˆå®Œäº†ï¼</h2>
        </div>
        <nav id="nav-menu" aria-label="ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼"></nav>
        <div id="menu-overlay" style="position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 999; display: none;"></div>
    </header>

    <main style="padding-right: 0; padding-left: 0;">
        <div id="animation-container">
            </div>

<div id="animation-container-other">
    <picture>
        <source srcset="mai.avif" type="image/avif">
        <source srcset="mai.png" type="image/png">
        <img src="mai.gif" alt="é€éã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³">
    </picture>
</div>

        <a href="../" 
            style="text-decoration:none; color:inherit; display:block;">
            <div style="
                background-color:#FFF;
                margin:40px;
                min-height:60px;
                display:flex;
                align-items:center;
                justify-content:center;
                padding:10px 20px;">
                <h3 style="margin:0;">é€šçŸ¥ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«æˆ»ã‚‹</h3>
            </div>
        </a>
    </main>

    <footer>
        <p>Mai's Platform</p>
        <div class="footer-links">
            <a href="https://www.youtube.com/@koinoyamaich" target="_blank" rel="noopener noreferrer">YouTube(main)</a> |
            <a href="https://www.youtube.com/@koinoyamaich" target="_blank" rel="noopener noreferrer">YouTube(sub)</a> |
            <a href="https://x.com/koinoya_mai" target="_blank" rel="noopener noreferrer">X (Twitter)</a> |
            <a href="https://www.fanbox.cc/@koinoya-mai" target="_blank" rel="noopener noreferrer">Pixiv Fanbox</a> |
            <a href="https://twitcasting.tv/c:koinoya_mai" target="_blank" rel="noopener noreferrer">TwitCasting</a>
        </div>
    </footer>
<script>
    document.addEventListener('DOMContentLoaded', function() {
  const appleContainer = document.getElementById('animation-container');
  const otherContainer = document.getElementById('animation-container-other');

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ–‡å­—åˆ—ã‚’å–å¾—
  const userAgent = navigator.userAgent.toLowerCase();

  // åˆ¤å®šãƒ•ãƒ©ã‚°
  let isAppleDevice = false;

  // Appleè£½å“ã®ä¸€èˆ¬çš„ãªUser Agentã«å«ã¾ã‚Œã‚‹æ–‡å­—åˆ—ã‚’ãƒã‚§ãƒƒã‚¯
  // ä¾‹: 'iphone', 'ipad', 'ipod', 'macintosh' (Mac)
  if (userAgent.includes('iphone') || 
      userAgent.includes('ipad') || 
      userAgent.includes('ipod') || 
      userAgent.includes('macintosh')) {
    isAppleDevice = true;
  }

  if (isAppleDevice) {
    // ğŸ Appleãƒ‡ãƒã‚¤ã‚¹ã®å ´åˆ
    
    // animation-container ã‚’è¡¨ç¤º
    appleContainer.classList.remove('hidden');
    
    // animation-container-other ã‚’éè¡¨ç¤º
    otherContainer.classList.add('hidden');
    
    console.log('Appleãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œå‡ºã—ã¾ã—ãŸã€‚Appleã‚³ãƒ³ãƒ†ãƒŠã‚’è¡¨ç¤ºã—ã¾ã™ã€‚');

  } else {
    // ğŸ¤– ãã®ä»–ã®ãƒ‡ãƒã‚¤ã‚¹ã®å ´åˆ
    
    // animation-container ã‚’éè¡¨ç¤º
    appleContainer.classList.add('hidden');
    
    // animation-container-other ã‚’è¡¨ç¤º
    otherContainer.classList.remove('hidden');
    
    console.log('ãã®ä»–ã®ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œå‡ºã—ã¾ã—ãŸã€‚Otherã‚³ãƒ³ãƒ†ãƒŠã‚’è¡¨ç¤ºã—ã¾ã™ã€‚');
  }
});
</script>
<script>
// ====================================================================
// WebGLã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹ (æä¾›ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’ç§»æ¤)
// WebGLã®åˆæœŸåŒ–ã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã€ãƒãƒƒãƒ•ã‚¡ã®ä½œæˆã‚’æ‹…å½“
// ====================================================================
class WebGLController {
    constructor(gl) {
        this.gl = gl;
    }

    // ã‚·ã‚§ãƒ¼ãƒ€ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
    createShader(type, source) {
        const gl = this.gl;
        let shader;

        switch (type) {
            case "vertex":
                shader = gl.createShader(gl.VERTEX_SHADER);
                break;
            case "fragment":
                shader = gl.createShader(gl.FRAGMENT_SHADER);
                break;
            default:
                return null;
        }

        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            return shader;
        } else {
            console.error("ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼:", gl.getShaderInfoLog(shader));
            alert("ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
            return null;
        }
    }

    // ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã‚·ã‚§ãƒ¼ãƒ€ã‚’ãƒªãƒ³ã‚¯ã™ã‚‹é–¢æ•°
    createProgram(vertexShader, fragmentShader) {
        const gl = this.gl;
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
            gl.useProgram(program);
            return program;
        } else {
            console.error("ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒªãƒ³ã‚¯ã‚¨ãƒ©ãƒ¼:", gl.getProgramInfoLog(program));
            return null;
        }
    }

    // VBO (é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ) ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
    createVbo(vboArray) {
        const gl = this.gl;
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vboArray), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return vbo;
    }

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’åˆæœŸåŒ–ãƒ»æ›´æ–°ã™ã‚‹é–¢æ•°
    initTexture(texture) {
        const gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š (å‹•ç”»ã‚’æ‰±ã†ãŸã‚ã®å®šå‹å‡¦ç†)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }

    updateTexture(video) {
        const gl = this.gl;
        const level = 0;
        const internalFormat = gl.RGBA;
        const srcFormat = gl.RGBA;
        const srcType = gl.UNSIGNED_BYTE;
        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, video);
    }
}

// ====================================================================
// GLSL ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ¼ãƒ‰
// ====================================================================

// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ (ç”»é¢å…¨ä½“ã‚’è¦†ã†å››è§’å½¢ã‚’å®šç¾©)
const vsSource = `
    attribute vec4 a_position;
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;
    void main() {
        gl_Position = a_position;
        v_texCoord = a_texCoord;
    }
`;

const fsSource = `
    // ç²¾åº¦å®£è¨€
    precision mediump float; 
    
    // Varyingå¤‰æ•°
    varying vec2 v_texCoord;
    
    // Uniformå¤‰æ•° (ä»Šå›ã¯ u_keyColor, u_threshold, u_smoothness ã¯ä½¿ç”¨ã—ãªã„ãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ äº’æ›æ€§ã®ãŸã‚æ®‹ã™)
    uniform sampler2D u_image;
    uniform vec3 u_keyColor;    
    uniform float u_threshold;  
    uniform float u_smoothness; 

    // å®šæ•°ã‚’å®šç¾©
    const vec3 u_despillColor = vec3(0.2, 0.2, 0.2); 
    const float GREEN_DOMINANCE_FACTOR = 0.7; 
    const float MIN_GREEN_VALUE = 0.4;
    const float DESPILL_STRENGTH = 3.0;
    
    const float MAX_ALPHA_THRESHOLD = 0.7;
    const float NOISE_ALPHA_THRESHOLD = 0.4;
    const float COLOR_STRENGTH_THRESHOLD = 0.4;

    void main() {
        vec4 color = texture2D(u_image, v_texCoord);
        vec3 rgb = color.rgb;
        
        float alpha = 1.0; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ä¸é€æ˜

        // --- ğŸ’¡ 1. æ–°ã—ã„RBGçµ¶å¯¾å€¤ã«ã‚ˆã‚‹é€éåˆ¤å®š ---
        const float R_MAX = 0.6;
        const float B_MAX = 0.6;
        const float G_MIN = 0.4;
        const float ALPHA_SMOOTHNESS = 0.05; // é€éã®å¢ƒç•Œã®æ»‘ã‚‰ã‹ã• (0.0ãŒæœ€ã‚‚é‹­ã„)

        // R, B, Gã®æ¡ä»¶ã‚’æº€ãŸã™ã‹ã©ã†ã‹
        bool condition_met = (rgb.r <= R_MAX) && 
                             (rgb.b <= B_MAX) && 
                             (rgb.g >= G_MIN);

        if (condition_met) {
            // æ¡ä»¶ã‚’æº€ãŸã—ãŸå ´åˆã€é€éã‚’é©ç”¨
            // Gæˆåˆ†ãŒ G_MIN ã‹ã‚‰ G_MIN + ALPHA_SMOOTHNESS ã®ç¯„å›²ã§ã€ã‚¢ãƒ«ãƒ•ã‚¡ã‚’ 1.0 -> 0.0 ã¸é·ç§»ã•ã›ã‚‹
            // GãŒé«˜ããªã‚‹ã»ã©ï¼ˆã¤ã¾ã‚Šã€ç´”ç²‹ãªç·‘ã«è¿‘ã„ã»ã©ï¼‰ã‚¢ãƒ«ãƒ•ã‚¡ã‚’ä¸‹ã’ãŸã„å ´åˆã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãƒ­ã‚¸ãƒƒã‚¯ã‚’å¤‰æ›´
            
            // é€éé‡ (Gæˆåˆ†ãŒ G_MIN ã‹ã‚‰é›¢ã‚Œã‚‹ã»ã© 1.0 ã«è¿‘ã¥ã)
            float g_diff = rgb.g - G_MIN;
            
            // smoothstepã‚’ä½¿ã£ã¦ã€GãŒG_MINä»˜è¿‘ã§0.0ã«ã€GãŒG_MIN+SMOOTHNESSã§1.0ã«ãªã‚‹ã‚ˆã†ã«è£œé–“
            // é€éã•ã›ã‚‹ (alpha = 0.0)
            alpha = 1.0 - smoothstep(0.0, ALPHA_SMOOTHNESS, g_diff);
            
        } else {
            // æ¡ä»¶ã‚’æº€ãŸã•ãªã‹ã£ãŸå ´åˆã€å®Œå…¨ã«ä¸é€æ˜ (alpha = 1.0)
            alpha = 1.0;
        }


        // --- 2. å¼·åŒ–ãƒ‡ã‚¹ãƒ”ãƒ«å‡¦ç† (ãã®ã¾ã¾æ®‹ã™) ---
        vec3 finalColor = rgb; 

        if (rgb.g > rgb.r * GREEN_DOMINANCE_FACTOR && 
            rgb.g > rgb.b * GREEN_DOMINANCE_FACTOR && 
            rgb.g > MIN_GREEN_VALUE) {
            
            float despillAmount = rgb.g - max(rgb.r, rgb.b); 
            despillAmount = clamp(despillAmount * DESPILL_STRENGTH, 0.0, 1.0);
            finalColor = mix(finalColor, u_despillColor, despillAmount);
        }

        // 3. æœ€çµ‚çš„ãªè‰²ã¨ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã‚’å‡ºåŠ›
        vec4 finalOutput = vec4(finalColor, alpha);

        // --- 4. ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— (ãã®ã¾ã¾æ®‹ã™) ---
        if (finalOutput.a > MAX_ALPHA_THRESHOLD) {
            finalOutput.a = 1.0;
        }
        
        // --- 5. ãƒã‚¤ã‚ºé™¤å» (ãã®ã¾ã¾æ®‹ã™) ---
        if (finalOutput.a < NOISE_ALPHA_THRESHOLD && 
            (finalOutput.r + finalOutput.g + finalOutput.b) > COLOR_STRENGTH_THRESHOLD) {
            
            finalOutput.a = 0.0;
        }

        gl_FragColor = finalOutput;
    }
`;

// ====================================================================
// ãƒ¡ã‚¤ãƒ³å‡¦ç†
// ====================================================================

window.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('animation-container');
    
    // 1. Canvasã¨Videoè¦ç´ ã‚’ä½œæˆ
    const canvas = document.createElement('canvas');
    canvas.id = 'animation-canvas';
    canvas.style.height = '90vh';
    canvas.style.width = 'auto';
    canvas.style.display = 'block';

    const video = document.createElement('video');
    video.id = 'video-source';
    video.src = 'showmai.mp4';
    video.loop = true;
    video.muted = true;
    video.playsInline = true;
    video.preload = 'auto';
    video.style.display = 'none'; 

    // ã‚³ãƒ³ãƒ†ãƒŠã«è¿½åŠ 
    container.appendChild(canvas);
    container.appendChild(video);

    const gl = canvas.getContext('webgl', { premultipliedAlpha: false }); // WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
    if (!gl) {
        console.error('WebGL not supported.');
        alert('ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯WebGLã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚');
        return;
    }

    const controller = new WebGLController(gl);

    // 2. ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒªãƒ³ã‚¯
    const vShader = controller.createShader("vertex", vsSource);
    const fShader = controller.createShader("fragment", fsSource);
    const program = controller.createProgram(vShader, fShader);

    if (!program) return;

    // 3. é ‚ç‚¹æƒ…å ± (ç”»é¢å…¨ä½“ã‚’è¦†ã†å››è§’å½¢) ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
    const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
    const texCoordAttributeLocation = gl.getAttribLocation(program, 'a_texCoord');

    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿: ç”»é¢å…¨ä½“ã‚’è¦†ã†å››è§’å½¢ (-1.0 to 1.0)
    const positions = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0];
    const texCoords = [0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0];

    const positionVbo = controller.createVbo(positions);
    const texCoordVbo = controller.createVbo(texCoords);

    // VBOã‚’æœ‰åŠ¹åŒ–
    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionVbo);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

    gl.enableVertexAttribArray(texCoordAttributeLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordVbo);
    gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);

    // 4. ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨ Uniform å¤‰æ•°ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
    const texture = gl.createTexture();
    controller.initTexture(texture);
    gl.uniform1i(gl.getUniformLocation(program, 'u_image'), 0); // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¦ãƒ‹ãƒƒãƒˆ0ã‚’ä½¿ç”¨

    const keyColorLocation = gl.getUniformLocation(program, 'u_keyColor');
    const thresholdLocation = gl.getUniformLocation(program, 'u_threshold');
    const smoothnessLocation = gl.getUniformLocation(program, 'u_smoothness');

    // ğŸ’¡ ã‚¯ãƒ­ãƒã‚­ãƒ¼è¨­å®šã®åˆæœŸå€¤ (0.0-1.0 ã«æ­£è¦åŒ–)
    // RGB(0, 175, 0) ã‚’ä½¿ç”¨ (G=175/255 â‰ˆ 0.686)
    const KEY_COLOR_GL = [0.0, 255.0 / 255.0, 0.0]; 
    const THRESHOLD_GL = 0.4; // è¨±å®¹è·é›¢ (ã“ã®å€¤ã‚ˆã‚Šè¿‘ã„è‰²ãŒæ¶ˆãˆå§‹ã‚ã‚‹)
    const SMOOTHNESS_GL = 0.7; // æ»‘ã‚‰ã‹ã• (ã“ã®å€¤ã®ç¯„å›²ã§åŠé€æ˜ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãŒé©ç”¨ã•ã‚Œã‚‹)

    gl.uniform3fv(keyColorLocation, new Float32Array(KEY_COLOR_GL));
    gl.uniform1f(thresholdLocation, THRESHOLD_GL);
    gl.uniform1f(smoothnessLocation, SMOOTHNESS_GL);
    
    // é€éå‡¦ç†ã®æœ‰åŠ¹åŒ–
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    // --- æç”»ãƒ«ãƒ¼ãƒ— ---
    video.onloadeddata = () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        video.play().catch(error => console.error("å‹•ç”»ã®å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸ:", error));
        requestAnimationFrame(drawLoop);
    };

    video.onerror = (e) => {
        console.error("å‹•ç”»ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", e);
    };

    function drawLoop() {
        if (video.paused || video.ended) {
            requestAnimationFrame(drawLoop);
            return;
        }

        // 1. ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ãƒ†ã‚¯ã‚¹ãƒãƒ£ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        controller.updateTexture(video);

        // 2. æç”»
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(drawLoop);
    }

    video.load();
});
</script>
</body>
</html>